Description of domain model & Justification
===========================================

Concepts and Relationships
--------------------------

* Act
    - Has a title, a duration in minutes and a unique ID.
    - Has one Artist.
    - Can have any number of performances.
    - Represented by the `Act` class.
* Artist
    - Has a name and unique ID.
    - Can perform any number of acts.
    - Represented by the `Artist` class.
* Performance
    - Has a start time, and pricing for both premium and 'cheap' seats, and a unique ID.
    - Takes place in any one theatre.
    - Is a performance of one act.
    - Has tickets issued, up to a maximum of one for each seat in the theatre.
    - Represented by the `Performance` class.
* Seat
    - Has a row number and a seat number.
    - Belongs to a given theatre.
    - May or may not be a 'premium' seat, with higher ticket price. This depends on the seat's row number and the number
      of rows in the theatre the seat is in.
    - Represented by the `Seat` class.
* Server
    - A server for the Theatre Booking System, represented by the interface `TBSServer` and implemented in `TBSServerImpl`.
* Theatre
    - All theatres in the TBS system have a square seating layout with equal number of rows as there are seats in a row.
    - Has a unique ID, seating dimension, floor area, and seats.
    - Represented by the `Theatre` class.
* Theatre file 
    - A tab-separated file with information on different theatres, to be read by `TBSServer#initialise`
    - The reading of this file is handled by the `TheatreParser` class, which generates `Theatre` objects
      from the file.
* Sales report
    - A formatted file giving information about tickets sold at different performances for an act.
    - Sales reports are generated via the `SalesReportFormatter` interface and its implementation, `TBSServerSalesReportFormatter`.
* Ticket
    - A ticket for a seat at a performance.
    - Has a price and a unique ID.
* Unique ID
    - A `String`-based identified for objects in the Theatre Booking System.
    - Unique IDs are generated by implementations of the IDGenerator interface.

Justification
-------------

The design is my best attempt at modelling the above domain model. Below I have noted
particular design choices I have made that I think are interesting and might
warrant discussion.

**Identifiable**

Almost all entities in the domain model (Act, Artist, Performance, Theatre, Ticket, etc...)
have a unique ID. The `Identifiable` interface allows for the abstraction of operations on objects with unique IDs.

**IdentifiableRepository and subclasses**

There are quite a few common operations on collections of identifiable objects specified in TBSServer 
(e.g. `TBSServer#getTheatreIDs()`, `TBSServer#getArtistIDs()`). An `IdentifiableRepository` is a collection which
stores `Identifiable` objects of type `T`, and has features including:

* Does not allow for storing of objects with duplicate IDs
* Has a `getAllIDs` method to quickly get all IDs in the repository - this is a very common operation.

There are several subclasses to `IdentifiableRepository` (such as `ActRepository`), which add type-specific
features to the base repository. For example, `ActRepository` has a `getArtistNames()` method to fetch the names
of all artists in the repository. This is used in `TBSServerImpl#getArtistNames()`. Having these methods in the
collection types removes responsibility from `TBSServerImpl` into a more reasonable place.

**IDGenerator**

The creation and management of unique IDs is the responsibility of the `IDGenerator` interface. It has a `createUniqueId()`
method, used to fetch a new unique ID, and is primarily used when creating new `Identifiable` objects. To ensure ID uniqueness,
most `Identifiable` objects take an `IDGenerator` parameter in their constructor. `IDGenerator` also has an `isValidID(String)` helper
method which is used to check if an ID is of the correct format. I have included 3 `IDGenerator` implementations: `UUIDIDGenerator`,
which creates a random UUID for every object, `AutoIncrementIDGenerator`, which increments a counter every time 
a new ID is generated and returns that counter as the ID, and lastly `CustomIDGenerator` which
allows for users to specify which ID should be generated next while ensuring uniqueness. `CustomIDGenerator` is used by
`TheatreParser` when reading theatres from the file, while `AutoIncrementIDGenerator` is used for everything else. `UUIDIDGenerator`
is currently unused.

**TBSException**

The whole idea of returning "ERROR <reason>" when there's a problem is rather arbitrary and I'd rather that doesn't
occur anywhere in my code other than `TBSServerImpl`. If there's a problem anywhere, the code will throw `TBSException`
which is then caught by `TBSServerImpl`. `TBSServerImpl` then outputs `"ERROR" + e.getMessage()`. `TBSException` is
unchecked.

**SalesReportFormatter**

The concept of a "sales report" is independent of the data model itself, and so I've abstracted this away using a
`SalesReportFormatter` interface. It generates a sales report (as a list of `String`) for a given act. The implementation
for this is provided by `TBSSalesReportFormatter` which formats the sales report as required for `TBSServer`.
